cex = 0.5,
)
legend("Topleft", #第一个参数描述legend出现在图表上面的位置
ConTingencyCRJob$`Credit Risk`, #第二个参数是legend的文字内容，以vector的形式输入
cex = 0.5, #cex表示画笔的粗细
fill = c("lightgreen", "lightblue") #要和上面的颜色匹配
)
legend("topleft", #第一个参数描述legend出现在图表上面的位置
ConTingencyCRJob$`Credit Risk`, #第二个参数是legend的文字内容，以vector的形式输入
cex = 0.5, #cex表示画笔的粗细
fill = c("lightgreen", "lightblue") #要和上面的颜色匹配
)
barplot(barmatrix,
col = c("lightgreen", "lightblue"),
main = "Credit Risk and Jobs",
beside = TRUE
)
legend("topleft", #第一个参数描述legend出现在图表上面的位置
ConTingencyCRJob$`Credit Risk`, #第二个参数是legend的文字内容，以vector的形式输入
cex = 0.5, #cex表示画笔的粗细
fill = c("lightgreen", "lightblue") #要和上面的颜色匹配
)
legend("topleft", #第一个参数描述legend出现在图表上面的位置
ConTingencyCRJob$`Credit Risk`, #第二个参数是legend的文字内容，以vector的形式输入
cex = 0.5, #cex表示画笔的粗细
fill = c("lightgreen", "lightblue") #要和上面的颜色匹配
)
legend("topleft", #第一个参数描述legend出现在图表上面的位置
ConTingencyCRJob$`Credit Risk`, #第二个参数是legend的文字内容，以vector的形式输入
cex = 0.5, #cex表示画笔的粗细
fill = c("lightgreen", "lightblue") #要和上面的颜色匹配
)
legend("topleft", #第一个参数描述legend出现在图表上面的位置
ConTingencyCRJob$`Credit Risk`, #第二个参数是legend的文字内容，以vector的形式输入
cex = 0.6, #cex表示画笔的粗细
fill = c("lightgreen", "lightblue") #要和上面的颜色匹配
)
legend("topleft", #第一个参数描述legend出现在图表上面的位置
ConTingencyCRJob$`Credit Risk`, #第二个参数是legend的文字内容，以vector的形式输入
#cex表示画笔的粗细
fill = c("lightgreen", "lightblue") #要和上面的颜色匹配
)
legend("topleft", #第一个参数描述legend出现在图表上面的位置
ConTingencyCRJob$`Credit Risk`, #第二个参数是legend的文字内容，以vector的形式输入
fill = c("lightgreen", "lightblue") #要和上面的颜色匹配
)
legend("topleft", #第一个参数描述legend出现在图表上面的位置
cex = 0.6,
ConTingencyCRJob$`Credit Risk`, #第二个参数是legend的文字内容，以vector的形式输入
fill = c("lightgreen", "lightblue") #要和上面的颜色匹配
)
legend("topleft", #第一个参数描述legend出现在图表上面的位置
cex = 0.6,
#第二个参数是legend的文字内容，以vector的形式输入
fill = c("lightgreen", "lightblue") #要和上面的颜色匹配
)
ConTingencyCRJob$`Credit Risk`
legend("left", #第一个参数描述legend出现在图表上面的位置
cex = 0.6,
ConTingencyCRJob$`Credit Risk`, #第二个参数是legend的文字内容，以vector的形式输入
fill = c("lightgreen", "lightblue") #要和上面的颜色匹配
)
legend("topleft", #第一个参数描述legend出现在图表上面的位置
cex = 0.6,
ConTingencyCRJob$`Credit Risk`, #第二个参数是legend的文字内容，以vector的形式输入
#要和上面的颜色匹配
)
legend(ConTingencyCRJob$`Credit Risk`, "topleft", #第一个参数描述legend出现在图表上面的位置
cex = 0.6,
#第二个参数是legend的文字内容，以vector的形式输入
#要和上面的颜色匹配
)
barplot(barmatrix,
col = c("lightgreen", "lightblue"),
main = "Credit Risk and Jobs",
beside = TRUE
)
legend()
legend("topleft",
ConTingencyCRJob$`Credit Risk`
)
legend("topleft",
ConTingencyCRJob$`Credit Risk`
)
#利用barplot画图
barplot(barmatrix,                    #第一个参数默认是我们的纯数据(vector或者matrix的数据类型)
names.arg=c("Female", "Male"),#names.arg参数管理柱子的名字
col=barColor,                 #col参数管理颜色
beside = TRUE,                #beside参数=TRUE，则male和female两列数据不会拼在一起，而是并排
main="Loan Purpose by Gender",#main参数管理大标题
ylim=c(0,80))                #ylim参数限制y轴的上下限
#首先把纯数据的那两列要单抓出来，而且要强制从data frame转化成matrix，到时候会放在bar plot的第一参数位置
barmatrix = as.matrix(by_loan_fmn[, c(2,3)]) #first we need to extract and convert the 2nd&3rd columns into a matrix
#准备调色盘向量
barColor = c("red","orange","yellow","green","blue","gray","pink","brown","cyan","violet")
#利用barplot画图
barplot(barmatrix,                    #第一个参数默认是我们的纯数据(vector或者matrix的数据类型)
names.arg=c("Female", "Male"),#names.arg参数管理柱子的名字
col=barColor,                 #col参数管理颜色
beside = TRUE,                #beside参数=TRUE，则male和female两列数据不会拼在一起，而是并排
main="Loan Purpose by Gender",#main参数管理大标题
ylim=c(0,80))                #ylim参数限制y轴的上下限
#画附注legend
legend("topleft",                     #第一个参数描述legend出现在图表上面的位置
by_loan_fmn$`Loan Purpose`,    #第二个参数是legend的文字内容，以vector的形式输入
cex = 0.5,                     #cex表示画笔的粗细
fill = barColor)                #fill参数是给这些文字填充颜色
barmatrix = as.matrix(ConTingencyCRJob[,2:dim(ConTingencyCRJob)[2]])
barColor = c("red","orange","yellow","green","blue","gray","pink","brown","cyan","violet")
barplot(barmatrix,
col = barColor,
main = "Credit Risk and Jobs",
beside = TRUE
)
legend("topleft",
ConTingencyCRJob$`Credit Risk`,
fill = barColor
)
by_loan_fmn$`Loan Purpose`
legend("topleft",
ConTingencyCRJob$`Credit Risk`,
)
legend("topleft",
ConTingencyCRJob$`Credit Risk`,
cex = 0.3
)
barplot(barmatrix,
col = c("lightgreen", "lightblue"),
main = "Credit Risk and Jobs",
beside = TRUE
)
legend("topleft",
ConTingencyCRJob$`Credit Risk`,
cex = 0.3
)
legend("topleft",
ConTingencyCRJob$`Credit Risk`,
cex = 1
)
barplot(barmatrix,
col = c("lightgreen", "lightblue"),
main = "Credit Risk and Jobs",
beside = TRUE
)
legend("topright",
ConTingencyCRJob$`Credit Risk`,
cex = 1
)
legend("topright",
ConTingencyCRJob$`Credit Risk`,
cex = 0.2)
barplot(barmatrix,
col = c("lightgreen", "lightblue"),
main = "Credit Risk and Jobs",
beside = TRUE
)
legend(ConTingencyCRJob$`Credit Risk`)
legend("right",ConTingencyCRJob$`Credit Risk`)
legend("right", c("high","low"))
barplot(barmatrix,
col = c("lightgreen", "lightblue"),
main = "Credit Risk and Jobs",
beside = TRUE
)
barplot(barmatrix,
col = c("lightgreen", "lightblue"),
main = "Credit Risk and Jobs",
beside = TRUE
)
legend("right", c("high","low"))
barmatrix = as.matrix(ConTingencyCRJob[,2:dim(ConTingencyCRJob)[2]])
barplot(barmatrix,
col = c("lightgreen", "lightblue"),
main = "Credit Risk and Jobs",
beside = TRUE
)
legend("right", c("high","low"))
barmatrix = as.matrix(ConTingencyCRJob[,2:dim(ConTingencyCRJob)[2]])
barplot(barmatrix,
col = c("lightgreen", "lightblue"),
main = "Credit Risk and Jobs",
beside = TRUE
)
<p style="color:blue">
Type your answer for 1bii here.
legend("top", c("high","low"))
barplot(barmatrix,
col = c("lightgreen", "lightblue"),
main = "Credit Risk and Jobs",
beside = TRUE,
legend("top", c("high","low"))
)
barplot(barmatrix,
col = c("lightgreen", "lightblue"),
main = "Credit Risk and Jobs",
beside = TRUE,
)
barmatrix = as.matrix(ConTingencyCRJob[,2:dim(ConTingencyCRJob)[2]])
barplot(barmatrix,
col = c("lightgreen", "lightblue"),
main = "Credit Risk and Jobs",
beside = TRUE,
)
legend("topright", ConTingencyCRJob$`Credit Risk`)
#要执行这一句必须要整块代码一起执行！否则会报错！
legend("topright",
ConTingencyCRJob$`Credit Risk`,
cex = 0.8,
fill = c("lightgreen", "lightblue")
)
barmatrix = as.matrix(ConTingencyCRJob[,2:dim(ConTingencyCRJob)[2]])
barplot(barmatrix,
col = c("lightgreen", "lightblue"),
main = "Credit Risk and Jobs",
beside = TRUE,
)
#要执行这一句必须要整块代码一起执行！否则会报错！
legend("topright",
ConTingencyCRJob$`Credit Risk`,
cex = 0.8,
fill = c("lightgreen", "lightblue")
)
## Type your codes here
HighCR = BD %>%
filter(`Credit Risk` == "High") %>%
count(name = "ha")
HighCR
BD
HighCR = BD %>%
filter(`Credit Risk` == "High")
HighCR
## Type your codes here
HighCR = BD %>%
filter(`Credit Risk` == "High") %>%
count(`Loan Purpose`)
HighCR
## Type your codes here
HighCRFreq = BD %>%
filter(`Credit Risk` == "High") %>%
count(`Loan Purpose`)
HighCRFreq
## Type your codes here
HighCRFreq = BD %>%
filter(`Credit Risk` == "High") %>%
count(`Loan Purpose`, name = "Frequency of Loan Purposes for High Risk Customers")
HighCRFreq
BD %>% filter(`Credit Risk` == "High") %>%
group_by(`Loan Purpose`) %>%
count(name = "Frequency of Loan Purposes for High Risk Customers")
# 方法3：
BD %>% filter(`Credit Risk` == "High") %>%
group_by(`Loan Purpose`) %>%
summarise("Frequency of Loan Purposes for High Risk Customers" = n())
#然后画出柱状图
barplot(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`,
col = rainbow(12),
)
#然后画出柱状图
barplot(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`,
col = rainbow(12),
main = "Frequency of Loan Purposes for High Risk Customers",
cex.names =
)
#然后画出柱状图
barplot(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`,
col = rainbow(12),
main = "Frequency of Loan Purposes for High Risk Customers",
xlab = "Number of Loans",
horiz = TRUE,
las = 1
)
#然后画出柱状图
barplot(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`,
names.arg = HighCRFreq$`Loan Purpose`,
col = rainbow(12),
main = "Frequency of Loan Purposes for High Risk Customers",
xlab = "Number of Loans",
horiz = TRUE,
las = 1,
)
#然后画出柱状图
barplot(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`,
names.arg = HighCRFreq$`Loan Purpose`,
col = rainbow(12),
main = "Frequency of Loan Purposes for High Risk Customers",
horiz = TRUE,
xlab = "Number of Loans",
cex.names = 0.5
las = 1,
#然后画出柱状图
barplot(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`,
names.arg = HighCRFreq$`Loan Purpose`,
col = rainbow(12),
main = "Frequency of Loan Purposes for High Risk Customers",
horiz = TRUE,
xlab = "Number of Loans",
cex.names = 0.5,
las = 1,
)
#然后画出柱状图
barplot(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`,
names.arg = HighCRFreq$`Loan Purpose`,
col = rainbow(12),
main = "Frequency of Loan Purposes for High Risk Customers",
horiz = TRUE,
xlab = "Number of Loans",
xlim = c(0, max(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`)*1.2)
cex.names = 0.5,
#然后画出柱状图
barplot(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`,
names.arg = HighCRFreq$`Loan Purpose`,
col = rainbow(12),
main = "Frequency of Loan Purposes for High Risk Customers",
horiz = TRUE,
xlab = "Number of Loans",
xlim = c(0, max(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`)*1.2),
cex.names = 0.5,
las = 1,
)
#然后画出柱状图
barplot(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`,
names.arg = HighCRFreq$`Loan Purpose`,
col = rainbow(12),
main = "Frequency of Loan Purposes for High Risk Customers",
horiz = TRUE,
xlab = "Number of Loans",
xlim = c(0, max(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`)*1.5),
cex.names = 0.5,
las = 1,
)
#然后画出柱状图
barplot(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`,
names.arg = HighCRFreq$`Loan Purpose`,
col = rainbow(12),
main = "Frequency of Loan Purposes for High Risk Customers",
horiz = TRUE,
xlab = "Number of Loans",
xlim = c(0, max(HighCRFreq$`Frequency of Loan Purposes for High Risk Customers`)*1.4),
cex.names = 0.5,
las = 1,
)
BD
BD.total = BD %>% select(`Total`) %>% arrange(desc(`Total`))
BD.total
BD.total$Percentage = BD.total$Total/sum(BD.total)
BD.total$Percentage
BD.total
#计算cumulative
BD.total$Cumulative = cumsum(BD.total$Percentage)
BD.total
rownames(BD)
BD.total
#继续创建一个新的column叫cum.order.perc
#计算的是当前订单数占总订单数的百分比
View(PO.sorted)
#继续创建一个新的column叫cum.order.perc
#计算的是当前订单数占总订单数的百分比
View(PO.sorted)
#workshop 3 template
##################################
# task 1 分析数据Purchase Orders #
##################################
'先做最开始的准备工作'
#1.import the files into R Studio
#注意！导入文件，绝对不是我们手动去输入命令！！！而是我们在File里面用import data来操作！
library(readxl)
Purchase_Orders = read_excel("Desktop/专业技能模块/计算机专业技能/学校课程/BT1101 Introduction to Business Analytics/Lecture Notes/数据文件/Purchase Orders.xlsx",
col_types = c("text", "text", "text",
"text", "numeric", "numeric", "numeric",
"numeric", "date", "date"), skip = 2)
View(Purchase_Orders)
#2.call library dplyr 引入dplyr库
library (dplyr)
glimpse(Purchase_Orders)  #其实就相当于在右边的global environment里面点开Purchase_order左边的蓝色按钮
str(Purchase_Orders)
#3.assign Purchase_Orders to a short file name you want
#这个数据框名字太长了，取个短一点的名字"PO"
PO = Purchase_Orders
'接下来开始进入正题，开始做一些有意义的事情了！'
#a find number of unique purchase order items
unique(PO$`Item Description`) # what is the function to obtain the unique item descriptions
#看这个变量中有多少种不同的东西：利用unique()函数，输入这个column。返回的是一个向量
#注意引用变量名的时候要用``而不是双引号！
length(unique(PO$`Item Description`)) # what function to use to get the number of unique items
#上一步unique函数能向我们展示有哪些东西，现在我要知道有多少个。
#利用length函数，将向量输入，返回里面元素的个数
'Frequency distribution for "Purchase Order Items" & "AP terms" 分别画出两个变量的频数分布表'
#方法1：使用dplyr函数库
freq_items = select (PO, `Item Description`) %>% #可以这样用select函数，但我更喜欢 PO %>% select(`Item Description`)
#其实没有select这一步也是可以的
group_by (`Item Description`) %>% #必须要有group_by，否则就是对全部的observation进行summarise
#现在就是依据item description的不同类型来进行summarise
summarise(COUNT= n()) #利用n()函数得到item description下面每一类及其对应的频数
#其实就等价于：效果一模一样
PO %>% count(`Item Description`, name = "COUNT")
freq_AP =  PO %>%
select (`A/P Terms (Months)`) %>%
group_by(`A/P Terms (Months)`) %>%
summarise(COUNT= n()) #由此得到A/P terms (Months)下面每一类及其对应的频数
#其实就等价于：效果一模一样
PO %>% count(`A/P Terms (Months)`, name = "COUNT")
'画图的原材料都准备好了，接下来就开始利用画图函数来画频数分布图了'
#频数分布图frequency distribution一定是用柱状图来表示的。利用barplot()函数
barplot(freq_items$COUNT,  #注意：第一个参数是我们要画图的纯数据（vector的形式）
#用$提取出来的直接是vector。如果用[]切片出来的，是data.frame，我们还需要用as.vector强制转化
main="Frequency Distribution of Purchase Order Items",
names.arg =freq_items$`Item Description` , #给每一根小柱子命名，用参数names.arg
cex.names=0.5, col="aquamarine", #cex表示画笔的细度，cex.names就是写小柱子的名字的笔的细度
xlab="Purchase Order Items", ylab="Frequency") #xlab和ylab都是轴的名字
par(las = 1) #添加这个函数，小柱子的名字都是竖着的！而不是平行着的！
par(las = 0) #这个函数让小柱子的名字平行回来！
#对par函数若要更多的了解，利用Help
barplot(freq_AP$Count,  #再次强调第一个参数是纯数字的向量！画的就是柱子的高度！
main="Frequency Distribution of A/P Terms (mths)",col="palegreen",
names.arg =freq_AP$`A/P Terms (Months)`,
xlab="A/P Terms (mths)", ylab="Frequency")
#注意：这里不可以使用直方图histogram！原因在于：直方图只能适用于连续型随机变量，不能给离散型随机变量用直方图！
#注意：直方图的使用方法!(虽然对于A/P Terms这个变量我们不应该用直方图)
hist(PO$`A/P Terms (Months)`, #直方图相比柱状图，我们不需要自制频数表，然后提取纯频数
#只需要将整个变量的column作为第一个参数，hist()函数就会自动计算各类的频数
#而且由于是对每一类自动计算频数，函数自然知道每一类对应的名字是什么，所以不需要names.arg
main = "Histogram for A/P Terms (mth)",
xlab = "A/P Terms (mths)",
col = "seagreen2")
#方法2：使用dplyr函数库，利用table()函数来帮助我们制作频数表（画图的原材料）
freq2_items = table(PO$`Item Description`)    #返回出来的东西，它的数据类型是table
#其实table的本质也就是一个向量，只不过每个元素都有名字的向量
freq2_AP = table(PO$`A/P Terms (Months)`)
#barplot
barplot(freq2_items,      #第一个参数我们输入的数据是一个table，每个数据都有名字，所以之后不需要命名
main="Frequency Distribution of Purchase Order Items",
cex.names=0.4, col="orchid1",
xlab="Purchase Order Items", ylab="Frequency")
barplot(freq2_AP,
main="Frequency Distribution of A/P Terms",
cex.names=0.8, col="orchid2",
xlab="A/P Terms", ylab="Frequency")
#1(b) contingency table for AP Term and Supplier 画出列联表：
#方法1：利用rpivotTable函数
library(rpivotTable)
rpivotTable(PO, #你要从哪儿提取数据
rows=c("A/P Terms (Months)"),
cols=c("Supplier"),
aggregatorName = "Count") #aggregatorName参数可在viewer里面修改，改成count as fraction of rows试试
#with rpivotTable, you can try to choose a different aggregatorName like "Count as Fraction of Row"
rpivotTable(PO)
#方法2：利用table函数
ctab_APS = table(PO$`A/P Terms (Months)`,PO$Supplier) #第一个参数作为列联表的row，第二个作为column
#我们发现，如果table()函数只有1个参数，那返回的就是这个参数里各类的频数表
#如果table()函数有2个参数，那么返回的就是列联表
#1(c) correlation coefficient 相关系数 （思考：为什么不用covariance？因为相关系数更标准化！）
library(psych) #要算相关系数，先引入psych数据库
corr.test(PO[5:8]) #利用corr.test,产生两张表：相关系数和p-value（理解他们两个之间的关系）
#输入的参数是data frame的variables
# try to run the below code and see what happens. notice the difference when only
# one argument is inside the ( ) versus 2 arguments
corr.test(PO[5:7], PO[8])
'probability value就是我们的p-value，我们在这里其实是进行了一个假设检验。
H0为变量X和变量Y之间是没有关系的。因此，我们第一步就应该先看p-value！p-value要是不小于0.05，
不论相关系数是多少都是没有意义的，是不可信的。'
#1(d) average, minimum and maximum cost per purchase order from each supplier
#计算一组数据的数字特征（最小值，最大值，均值）
PO %>%
group_by(Supplier) %>%                       #数据要summarise要根据supplier的种类来进行分类
summarise (minimum = min(`Cost per order`),  #求最小值用min函数
maximum = max(`Cost per order`),  #求最大值用max函数
average = mean(`Cost per order`)) #求平均值用mean函数
#尽量不要把变量名字取的和函数的名字一样,最好换成minimum
#1e Parecto analysis for Cost per order 帕累托分析
#方法1：利用base R的函数（推荐）
PO.sorted = arrange(PO, desc(`Cost per order`))
#利用arrange函数根据Cost per order将PO降序排列
#所谓降序，就是最大的Cost per order放在上面，越往下越小
PO.sorted$cum.cpo = cumsum(PO.sorted$`Cost per order`)
#创建一个新column叫cum.cpo
#利用cumsum()函数对cpo那一列进行累加计算
PO.sorted$cum.cpo.perc = PO.sorted$cum.cpo/sum(PO.sorted$`Cost per order`)
#继续创建一个新的column叫cum.cpo.perc
#计算的是每一个cpo的累加值在整体cpo总值的占比
PO.sorted$cum.order.perc = row(PO.sorted)/nrow(PO.sorted)
#继续创建一个新的column叫cum.order.perc
#计算的是当前订单数占总订单数的百分比
View(PO.sorted)
#
row(BD.total)
#计算cumulative percentyage of customers from top most saving
row(BD.total)/nrow(BD.total)
#计算cumulative percentyage of customers from top most saving
row(BD.total)/nrow(BD.total)[1]
#计算cumulative percentyage of customers from top most saving
row(BD.total)/nrow(BD.total)[1,]
#计算cumulative percentyage of customers from top most saving
row(BD.total)/nrow(BD.total)[,1]
#计算cumulative percentyage of customers from top most saving
(row(BD.total)/nrow(BD.total))[1]
#计算cumulative percentyage of customers from top most saving
(row(BD.total)/nrow(BD.total))
#计算cumulative percentyage of customers from top most saving
class(row(BD.total)/nrow(BD.total))
#计算cumulative percentyage of customers from top most saving
class((1:dim(BD.total)[1])/nrow(BD.total))
#计算cumulative percentyage of customers from top most saving
(1:dim(BD.total)[1])/nrow(BD.total)
(1:dim(BD.total)[1])
nrow(BD.total)
#计算cumulative percentyage of customers from top most saving
(1:nrow(BD.total))/nrow(BD.total)
rownames(BD.total)
#计算cumulative percentyage of customers from top most saving
BD.total$CumulativeCustomers = (1:nrow(BD.total))/nrow(BD.total)
BD.total
View(BD.total)
